// generated by authenticaTed v1.0.0 at 2016-12-27 20:21:22.129089843 -0300 BRT

// generated by authenticaTed v1.0.0 at 2016-12-27 20:21:13.322468164 -0300 BRT

// generated by authenticaTed v1.0.0 at 2016-12-27 20:20:38.590776334 -0300 BRT

// generated by authenticaTed v1.0.0 at 2016-12-27 20:20:25.441216868 -0300 BRT

// generated by authenticaTed v1.0.0 at 2016-12-27 20:20:19.73311948 -0300 BRT

// generated by authenticaTed v1.0.0 at 2016-12-27 20:20:14.463216622 -0300 BRT

// generated by authenticaTed v1.0.0 at 2016-12-27 20:20:13.097906192 -0300 BRT

// generated by authenticaTed v1.0.0 at 2016-12-27 20:20:04.764965037 -0300 BRT

// generated by authenticaTed v1.0.0 at 2016-12-27 20:19:04.450823181 -0300 BRT

// generated by authenticaTed v1.0.0 at 2016-12-27 20:18:58.902936258 -0300 BRT

package util

import (
	"math"
	"math/big"
	"math/rand"
	"time"
)

func init() {
	rand.Seed(time.Now().UTC().UnixNano())
}

var (
	int32Min int64 = 1000000000
	int64Min int64 = 1000000000000000000
)

// GeneratePrime number
func GeneratePrime(mode int) (uint64, error) {
	var r, min, n int64

	if mode == 32 {
		min = int32Min
		n = math.MaxInt32 - int32Min
	} else {
		min = int64Min
		n = math.MaxInt64 - int64Min
	}

	for {
		r = min + rand.Int63n(n)

		if big.NewInt(r).ProbablyPrime(100) {
			return uint64(r), nil
		}
	}

	return 0, nil
}
