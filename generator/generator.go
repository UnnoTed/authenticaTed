package generator

import (
	"bytes"
	"errors"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"text/template"
	"time"

	"github.com/UnnoTed/authenticaTed/auth/util"
	"github.com/UnnoTed/authenticaTed/generator/utils"
	"github.com/UnnoTed/commenTed"
	"github.com/ungerik/go-dry"
	"golang.org/x/tools/imports"
)

// Information that will be used in go templates
type Information struct {
	Activation bool
	Package    string
	DeadCode   bool

	Database           string
	Primes             []uint64
	SecretPackage      string
	DestinationPackage string
	Logging            bool
	Debug              bool

	Fields []*Field
}

var c *Config
var version = "v1.0.0"

// Run the parser and generator
func Run() error {
	var err error
	c, err = NewConfig()
	if err != nil {
		return err
	}

	log.Println("Config loaded, checking for Go file", c.File)

	// check for the Go file
	if !dry.FileExists(c.File) {
		return errors.New("Error: the file you specified for authenticaTed doesn't exists")
	}

	log.Println("Reading Go file...")

	// read the Go file
	data, err := ioutil.ReadFile(c.File)
	if err != nil {
		return err
	}

	log.Println("Parsing Go file...")
	parsed, err := Parse(c.File, data)
	if err != nil {
		return err
	}

	err = Generate(parsed)
	if err != nil {
		return err
	}

	//err = ioutil.WriteFile("user_test.go", data, 0644)
	return nil
}

// Generate copies all files from the auth package
// and exec it as a text template before writing it at the destination
func Generate(list *Skeleton) error {
	// get struct fields from the go file specified in the config
	for name, field := range list.Fields {
		if _, ok := c.Schema[name]; ok {
			log.Println(name, field.Type)
		}
	}

	// get runtime dir
	_, filename, _, ok := runtime.Caller(0)
	if !ok {
		panic(errors.New("Error: Can't get runtime dir"))
	}

	dir := filepath.Dir(filename)
	dir = filepath.Dir(dir)
	dir = filepath.Join(dir, "auth")

	var err error
	primes := make([]uint64, 5)

	// generate prime numbers to hide the user ids
	size := []int{32, 64, 32, 64, 64}
	for i, s := range size {
		p, err := util.GeneratePrime(s)
		if err != nil {
			return err
		}

		primes[i] = p
	}
	if err != nil {
		return err
	}

	// get info to inject into the go templates
	i := Information{
		Activation: false,
		Package:    c.Package,
		DeadCode:   false,
		Database:   "postgresql",
		Primes:     primes,
		Logging:    c.Logging,
		Debug:      c.Debug,
		// SecretPackage: "github.com/UnnoTed/secret",
	}

	// get struct fields from the go file specified in the config
	for _, field := range list.Fields {
		i.Fields = append(i.Fields, field)
	}

	dirs := []string{dir}
	if c.API != "" {
		dirs = append(dirs, filepath.Join(dir, "../api/"+c.API))
	}

	log.Println("dirsss", dirs)

	var gd string
	for _, dir := range dirs {
		log.Println(dir)
		err = filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}

			log.Println(info.Name())

			// ignore dirs
			if info.IsDir() {
				return nil
			}

			// wp = write path
			// d = destination
			sub := strings.TrimPrefix(path, dir)
			var wp string
			if strings.HasSuffix(dir, "echo") {
				wp = filepath.Join(dir, sub)
			} else {
				wp = filepath.Join(wd, sub)
			}
			d := filepath.Dir(wp)

			// working dir
			gd = wd

			// get package path for go files
			if !strings.HasSuffix(d, "errors") && !strings.HasSuffix(d, "logger") && !strings.HasSuffix(d, "util") {
				if i.SecretPackage == "" {
					i.SecretPackage = utils.GetCurrentPackage(d) + "/secret"
				}

				if !strings.HasSuffix(d, "secret") && i.DestinationPackage == "" {
					i.DestinationPackage = utils.GetCurrentPackage(d)
				}
			}

			// read file
			data, err := ioutil.ReadFile(path)
			if err != nil {
				return err
			}

			// parse template
			tmpl, err := template.New(info.Name()).Parse(helpers + string(data))
			if err != nil {
				panic(err)
			}

			// exec template
			infoText := "// generated by authenticaTed " + version + " at " + time.Now().String()
			buff := bytes.NewBufferString(infoText)
			err = tmpl.Execute(buff, i)
			if err != nil {
				return err
			}

			// creates dir when needed
			if !dry.FileExists(d) {
				err = os.Mkdir(d, 0777)
				if err != nil {
					return err
				}
			}

			// format only .go files
			fmted := buff.Bytes()

			// remove comments
			fmted = commenTed.Parse(fmted, false)

			// gofmt
			if filepath.Ext(path) == ".go" {
				fmted, err = format.Source(fmted)
				if err != nil {
					log.Println("ERROR:", info.Name())
					return err
				}
			}

			// write the file
			err = ioutil.WriteFile(wp, fmted, 0644)
			if err != nil {
				return err
			}

			return nil
		})

		if err != nil {
			return err
		}
	}

	// build secret data with password encryption key
	if err = InsertSecret(gd, "secret"); err != nil {
		return err
	}

	return nil
}

// InsertSecret creates a secret.go with
// information that shouldn't change after re-generating
func InsertSecret(path, pkg string) error {
	var err error
	path = filepath.Dir(path)
	path = filepath.Join(path, "/secret/")

	log.Println(path)
	secretFilePath := filepath.Join(path, "secret.go")

	// doesn't do anything when it already exists
	if dry.FileExists(path) && dry.FileExists(secretFilePath) {
		return nil
	}

	// creates dir when needed
	if !dry.FileExists(path) {
		err = os.Mkdir(path, 0777)
		if err != nil {
			return err
		}
	}

	s := struct {
		TokenSecret   string
		EncryptionKey string
	}{
		TokenSecret:   dry.RandomHexString(32),
		EncryptionKey: dry.RandomHexString(32),
	}

	data := `package secret

var (
	TokenSecret   = []byte("{{.TokenSecret}}")
	EncryptionKey = "{{.EncryptionKey}}"
)
`

	// parse template
	tmpl, err := template.New("secret/secret.go").Parse(data)
	if err != nil {
		return err
	}

	// exec template
	infoText := "// generated by authenticaTed at " + time.Now().String() + `
// REALLY IMPORTANT
// NEVER DELETE THIS FILE OR YOUR USERS WILL NOT BE ABLE TO LOG IN THEIR ACCOUNTS!!!
// MAKE A BACKUP OF THIS FILE

`
	buff := bytes.NewBufferString(infoText)
	err = tmpl.Execute(buff, s)
	if err != nil {
		return err
	}

	sct, err := imports.Process(filepath.Base(path), buff.Bytes(), nil)
	if err != nil {
		return err
	}

	// writes the file without "write" permission -> 544
	// check https://en.wikipedia.org/wiki/Chmod#Octal_modes
	err = ioutil.WriteFile(secretFilePath, sct, 0544)
	if err != nil {
		return err
	}

	// .gitignore
	gitIgnorePath := filepath.Join(path, ".gitignore")
	var lines []string

	// write into the .gitignore when it already exists
	if dry.FileExists(path) && dry.FileExists(gitIgnorePath) {
		exists := false

		// read .gitignore
		lines, err = dry.FileGetLines(gitIgnorePath, 10*time.Second)
		if err != nil {
			return err
		}

		// check if file is in .gitignore
		for _, line := range lines {
			if line == "source.go" {
				exists = true
				break
			}
		}

		// line not found
		if !exists {
			lines = append(lines, "source.go")
		}
	} else {
		lines = append(lines, "source.go")
	}

	// save .gitignore
	return dry.FileSetLines(gitIgnorePath, lines)
}
